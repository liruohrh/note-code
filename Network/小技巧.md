- `localhost:0`：表示让系统分配端口
- 监听的addr中的host只能被一个服务绑定，0.0.0.0会绑定所有网络接口，当某个接口被其他服务绑定，则流量会到这个服务而不是0.0.0.0服务
	- 一般情况下，如果没有绑定host，默认都是localhost
# Windows 上0.0.0.0可能被重复绑定
- Windows 的 `SO_REUSEADDR` 比 Linux 宽松得多
    只要两边都设置了 `REUSEADDR`，完全相同的 `0.0.0.0:Port` 也能共存。
- 只要在监听配置中设置SO_EXCLUSIVEADDRUSE，就可以完全禁止被其他socket强制绑定，下面是go的例子
	- 但是如果不是绑定0.0.0.0，还是会被强制占用127.0.0.1
	- 如果是后启动的，则仅占localhost
	- 如果配置tcp而不是tcp4，则可能还是会被强制占用127.0.0.1
```go
//禁止被其他socket强制绑定  
const SO_EXCLUSIVEADDRUSE = 0x00000010  
listenCfg := net.ListenConfig{  
    Control: func(network, address string, c syscall.RawConn) error {  
       var err error  
       err0 := c.Control(func(fd uintptr) {  
          // 下独占标志  
          err = windows.SetsockoptInt(windows.Handle(fd),  
             windows.SOL_SOCKET,  
             SO_EXCLUSIVEADDRUSE, 1)  
       })  
       if err != nil && err0 != nil {  
          return fmt.Errorf("control: %w: set SO_EXCLUSIVEADDRUSE: %w", err0, err)  
       } else if err != nil {  
          return fmt.Errorf("set SO_EXCLUSIVEADDRUSE: %w", err)  
       } else if err0 != nil {  
          return fmt.Errorf("control: %w", err0)  
       }  
       return nil  
    },  
}  
ln, err := listenCfg.Listen(context.Background(), "tcp4", "0.0.0.0:8082")  
if err != nil {  
    panic(fmt.Sprintf("listen fail: %v", err))  
}  
  
// 3. 正常构造 http.Serversrv := &http.Server{  
    Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {  
       fmt.Fprintf(w, "hi, I'm the real 8082!\n")  
    }),  
    ReadHeaderTimeout: 3 * time.Second,  
}  
  
// 4. 优雅退出  
go func() {  
    sig := make(chan os.Signal, 1)  
    signal.Notify(sig, os.Interrupt, syscall.SIGTERM)  
    <-sig  
    srv.Shutdown(context.Background())  
}()  
  
fmt.Println("serving on 0.0.0.0:8082 with SO_EXCLUSIVEADDRUSE")  
if err := srv.Serve(ln); err != nil && !errors.Is(err, http.ErrServerClosed) {  
    fmt.Printf("serve err: %v\n", err)  
}
```
